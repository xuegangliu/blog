{"meta":{"title":"俩天的博客","subtitle":"日常记录","description":"person blog","author":"xuegangliu","url":"https://github.com/xuegangliu/blog"},"pages":[{"title":"关于我","date":"2016-11-08T17:39:07.000Z","updated":"2018-01-09T14:08:37.000Z","comments":true,"path":"about.html","permalink":"https://github.com/xuegangliu/blog/about.html","excerpt":"","text":"刘雪岗 内蒙古师范大学 计算机科学与技术 本科 联系方式 手机：176-0088-5165 Email：lxghoney@163.com QQ/微信号：1453860636 工作经历 亚信中国 2017.07-至今CUC部门铁塔支持部 中交兴路 2016.08-2017.05油品事业部 亚信中国 （ 2017年07月 ~ 至今 ）铁塔CRM我在此项目负责铁塔变更、追溯业务开发，每周任务上线、问题处理。在项目中负责整个CRM后台项目的上线实施操作，上线问题处理。面对线上问题，对于线上环境出现的问题，利用JVM虚拟机命令查询出线程执行情况，并快速解决问题。 中交兴路 （ 2016年08月 ~ 2017年05月 ）elap日志分析平台项目介绍：对日志进行收集(主要通过syslog、nxlog)、分析、字段提取。对日志进行日志流分类，日志警告通知、日志仪表盘的展示，以及一些系统配置，日志地图统计。工作任务：搭建服务器环境，在服务器设置日志输入端口，在客户端将日志发送到服务端，存储到elasticsearch中，进行聚合统计出图。利用自定义语句根据antlr语法分析，统计最终的数据从而用echarts进行出图展示。日志模式进行日志消息相似度计算得出统计数据。项目使用技术：Guice+guava+react+antlr+echart数据库：mongo搜索引擎及存储：Elasticsearch 柴油联名卡项目介绍：中石化与中交兴路推出柴油专用联名卡。联名卡由个人用户企业用户进行申请，进行对油卡的申请、充值、授信、返利、开票等。工作任务：负责联名卡企业办卡申请模块的开发，与前端人员进行接口联调。负责油卡后台管理油卡审核模块、油卡管理、会员管理，以及提供给金融组所需要的接口。完成项目一期开发，使项目成功上线。项目使用技术：Spring+SpringMVC+Mybatis+Vue服务间调用：dubbo、hession数据库：mysql(docker)、redis 蓝海保险系统项目介绍：国家电网英大传媒内部人员查阅电力案例的文档信息，它包含案例展示、会员中心、案例搜索、上传案例、收藏案例、打印案例、会员登陆、后台网站资源管理、后台统 计分析、后台积分管理、后台语义词表、后台资源加工、后台资源 管理、后台授权管理等。工作任务：分析讨论业务需求，编写数据说明书，数据字典。负责电力案例分类模块研发，案例库关键词搜索、网站资源等模块的研发。 项目技术：Spring+SpringMVC+JPA+shiro+ueditor+angular+avalon 数据库：mysql 服务器：tomcat 开源项目和作品个人作品 开源项目 ACM：ACM评测系统 graylog2：日志分析系统 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"友情链接","date":"2016-11-08T17:39:07.000Z","updated":"2019-01-09T14:08:37.000Z","comments":true,"path":"links.html","permalink":"https://github.com/xuegangliu/blog/links.html","excerpt":"","text":"个人链接 book 友情链接系统链接 卡拉云后台系统 blog大牛 翟永超 阮一峰 不会就问咯 java1234-小锋 数据结构与算法 skywang12345 其它 洪海亮 我全科 数据库 寒夕若梦"},{"title":"categories","date":"2016-03-02T12:33:16.000Z","updated":"2022-05-26T07:55:04.561Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/xuegangliu/blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"JDK1.5新特性","slug":"java/java_5_skill","date":"2019-11-06T10:30:12.000Z","updated":"2019-11-06T10:30:12.000Z","comments":true,"path":"2019/11/06/java/java_5_skill/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/11/06/java/java_5_skill/","excerpt":"","text":"JDK1.5新特性 自动装箱与拆箱 基本数据类型与封装的基本类型互相转换 枚举 java.lang.Enum 1234567891011121314151617181920212223242526272829303132package java.lang.annotation;/** * Annotation retention policy. The constants of this enumerated type * describe the various policies for retaining annotations. They are used * in conjunction with the &#123;@link Retention&#125; meta-annotation type to specify * how long annotations are to be retained. * * @author Joshua Bloch * @since 1.5 */public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; 静态导入import static java.lang.Math.PI; 可变参数（Varargs） 1234567891011121314151617181920/** * A * &lt;p&gt; * This is description * &lt;/p&gt; * * @author xuegangliu 2019/11/06 * @since 1.8 **/public class A &#123; public static void main(String[] args) &#123; new A().test(1,2,3,4,5); &#125; public void test(int... a)&#123; for(int t:a)&#123; System.out.println(t); &#125; &#125;&#125; 内省（Introspector），访问某个对象属性的 getter/setter 方法的API。java.beans.* 泛型(Generic)（包括通配类型/边界类型等） For-Each循环 注解 协变返回类型：实际返回类型可以是要求的返回类型的一个子类型 5.6.7.8.9代码示例 package org.lxg.basic.jdk5;import lombok.extern.slf4j.Slf4j;import org.junit.Test;import org.lxg.basic.annotation.AnnotationA;import org.lxg.basic.annotation.AnnotationB;import org.lxg.basic.annotation.BasicInfo;import org.lxg.basic.annotation.filed.BaseFiled;import org.lxg.basic.annotation.method.BasicMethod;import java.beans.BeanInfo;import java.beans.IntrospectionException;import java.beans.Introspector;import java.beans.PropertyDescriptor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;import static java.lang.Math.max;/ Jdk5Tests This is description @author xuegangliu 2019/11/06 * @since 1.8 /@Slf4jpublic class Jdk5Tests { @Test public void testAnnotationA(){ Class clsA = AnnotationA.class; log.info(“clsA class:{}”,clsA.getName()); BasicInfo basicTypeA = (BasicInfo) clsA.getAnnotation(BasicInfo.class); log.info(“clsA {},{}”,basicTypeA.version(),basicTypeA.description()); Field[] fields1 = clsA.getDeclaredFields(); log.info(“———– field ——————-“);// Field[] fields = clsA.getFields();// for (Field field : fields) {// BaseFiled baseFiled = field.getAnnotation(BaseFiled.class);// if (baseFiled != null) {// log.info(“field:{},{},{}”,field.getName(),baseFiled.description(),baseFiled.Old());// }// } for (Field field : fields1) { BaseFiled baseFiled = field.getAnnotation(BaseFiled.class); if (baseFiled != null) { log.info(“field:{},{},{}”,field.getName(),baseFiled.description(),baseFiled.Old()); } } log.info(“———— methods ——————“); Method[] methods = clsA.getDeclaredMethods(); for(Method method:methods){ BasicMethod methodInfo=method.getAnnotation(BasicMethod.class); if(methodInfo!=null){ log.info(“Annotation: method:{},author:{},date:{},version:{}”,method.getName(),methodInfo.author(),methodInfo.date(),methodInfo.version()); } } } @Test public void testAnnotationB(){ Class clsB = AnnotationB.class; log.info(“clsB class:{}”,clsB.getName()); BasicInfo basicTypeB = (BasicInfo) clsB.getAnnotation(BasicInfo.class); log.info(“clsB {},{}”,basicTypeB.version(),basicTypeB.description()); Field[] fields1 = clsB.getDeclaredFields(); log.info(“———– field ——————-“);// Field[] fields = clsA.getFields();// for (Field field : fields) {// BaseFiled baseFiled = field.getAnnotation(BaseFiled.class);// if (baseFiled != null) {// log.info(“field:{},{},{}”,field.getName(),baseFiled.description(),baseFiled.Old());// }// } for (Field field : fields1) { BaseFiled baseFiled = field.getAnnotation(BaseFiled.class); if (baseFiled != null) { log.info(“field:{},{},{}”,field.getName(),baseFiled.description(),baseFiled.Old()); } } log.info(“———— methods ——————“); Method[] methods = clsB.getDeclaredMethods(); for(Method method:methods){ BasicMethod methodInfo=method.getAnnotation(BasicMethod.class); if(methodInfo!=null){ log.info(“Annotation: method:{},author:{},date:{},version:{}”,method.getName(),methodInfo.author(),methodInfo.date(),methodInfo.version()); } } } @Test public void testBox(){ int i=1; Integer j=i; log.error(“int i:{},Integer j:{}”,i,j); Integer x=256; int y=x; log.error(“Integer x:{},int y:{}”,x,y); } @Test public void testEnum(){ for (EnumA e : EnumA.values()) { log.error(“code:{},msg:{}”,e.code,e.msg); } } @Test public void testImportStatic(){ log.error(“(import static java.lang.Math.max) max(11,12):{}”,max(11,12)); } @Test public void testChangeArgs(){ Jdk5Tests.changeArgs(1,2,3,5,4); } @Test public void testBeanGetSet() throws IntrospectionException, InvocationTargetException, IllegalAccessException { Student student = new Student(“Tony”,28); PropertyDescriptor propertyDescriptorName = new PropertyDescriptor(“name”, Student.class); Method writeNameMethod = propertyDescriptorName.getWriteMethod(); Method readNameMethod = propertyDescriptorName.getReadMethod(); log.error(“{}”,readNameMethod.invoke(student).toString()); writeNameMethod.invoke(student, “Tony1”); log.error(“{}”,readNameMethod.invoke(student).toString()); BeanInfo beanInfo = Introspector.getBeanInfo(student.getClass()); PropertyDescriptor[] pd = beanInfo.getPropertyDescriptors(); for (int i = 0; i &lt; pd.length; i++) { PropertyDescriptor p=pd[i]; log.error(“{}”,p.getName()); } } @Test public void testGeneric(){ List list = new ArrayList(); list.add(1);// list.add(“err”); log.error(“size:{}”,list.size()); } @Test public void testForEach(){ Student tony=new Student(“Tony”,11); Student lily=new Student(“Lily”,13); List list=new ArrayList(); list.add(tony); list.add(lily); for (Student student : list) { log.error(“name:{},age:{}”,student.getName(),student.getAge()); } }// public ? super Student changeReturn(){//// return null;// } public static void changeArgs(int… args){ for (int i = 0; i &lt; args.length; i++) { log.error(“{}”,args[i]); } } private enum EnumA{ OK(200,”OK”), NO(404,”No”); private String msg; private Integer code; EnumA(Integer code,String msg){ this.msg=msg; this.code=code; } }}class Base{ public Base(){} public List getList(){ return new ArrayList&lt;&gt;(); }}class Student extends Base{ private String name; private Integer age; public Student(String name,Integer age){ this.name=name; this.age=age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public ArrayList getList(){ // 重新父类方法,返回值是父类返回值的子类即协变返回类型 return new ArrayList&lt;&gt;(); }}","categories":[{"name":"java","slug":"java","permalink":"https://github.com/xuegangliu/blog/categories/java/"}],"tags":[{"name":"knowledge","slug":"knowledge","permalink":"https://github.com/xuegangliu/blog/tags/knowledge/"},{"name":"java_base","slug":"java-base","permalink":"https://github.com/xuegangliu/blog/tags/java-base/"}]},{"title":"开发中遇到的问题记录","slug":"problem/work-problem","date":"2019-08-30T10:20:53.000Z","updated":"2019-08-30T10:20:53.000Z","comments":true,"path":"2019/08/30/problem/work-problem/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/08/30/problem/work-problem/","excerpt":"","text":"开发中遇到的问题记录1.idea启动项目后页面不能访问解决方案：新版本部署tomcat需要勾选Deploy 2.idea中启动tomcat项目，控制台乱码 原因：tomcat编码与本地环境编码不一致 解决方案：在catalina.out|catalina.sh文件中的JAVA_OPTS后加-Dfile.encoding=UTF8 -Dsun.jnu.encoding=UTF8 3.公网无法下载，安装jar到本地仓库 mvn install:install-file -Dfile=jar包的位置 -DgroupId=jar包的groupId -DartifactId=jar包的artifactId -Dversion=jar包的version -Dpackaging=jar 4.用一些证书后，报java.security.InvalidKeyException: Illegal key size异常 原因：安全证书果密钥大于128报错，java默认的安全证书是受限制的 解决方案：替换环境中%JDK_HOME%\\jre\\lib\\security目录下的local_policy.jar和US_export_policy.jar blog文章 5.springboot中jpa默认的查询中，对象与数据表的映射时，当数据库中表中字段为null时，查询错误 原因：对象映射字段为基本类型导致null映射错误 解决方案：将基本数据类型修改为包装类型 6.oracle merge into用到自增序列,生成多次无用的序列 原因:存储过程中,对主键设置时,会造成序列很快用完 https://blog.csdn.net/zlh313_01/article/details/82745526 7.java.lang.UnsatisfiedLinkError: no jacob-1.17-x64 in java.library.path 原因：未找到匹配信息 需要把jacob-1.17-x64.dll添加到系统的变量文件下 8.oracle sql语句查询,子查询查出数据不正确 原因: 未按别名展示出列，(子查询中的字段在上级中存在同样字段,未添加表别名，按自身的值去查询) 字段展示，带上表别名展示 9.前端ajax请求数据,后端没有按key取到值 原因: 传过去为string，未按key：value去传过去 按key、value格式传过去 10.在https服务中发ajax请求http被浏览器block 原因: (从https发送http请求是不可以) 协议，域名，端口有任何一个的不同，就被当作是跨域,请求https 11.ios h5页面软键盘弹出后造成的触控不准BUG以及其解决方法 原因: ios h5页面软键盘弹出后造成的触控不准 https://blog.csdn.net/soband_xiang/article/details/85697948 12.hibernate sessionFactory hql查询完， 查询出的的bean 重新set filed时会发生更新数据操作 原因: sessionFactory查询完，未释放sessionFactory https://blog.csdn.net/shine0181/article/details/6187939","categories":[{"name":"problem","slug":"problem","permalink":"https://github.com/xuegangliu/blog/categories/problem/"}],"tags":[{"name":"java_base","slug":"java-base","permalink":"https://github.com/xuegangliu/blog/tags/java-base/"}]},{"title":"测试文档编写","slug":"problem/bug_doc","date":"2019-06-03T13:16:43.000Z","updated":"2019-06-03T13:16:43.000Z","comments":true,"path":"2019/06/03/problem/bug_doc/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/06/03/problem/bug_doc/","excerpt":"","text":"Bug 描述A clear and concise description of what the bug is. 复现复现步骤: Go to ‘…’ Click on ‘….’ Scroll down to ‘….’ See error 预期结果A clear and concise description of what you expected to happen. 截图If applicable, add screenshots to help explain your problem. 附加信息Add any other context about the problem here. 单机服务卸流 漏桶算法 将流量放入桶中，漏桶同时也按照一定的速率流出，如果流量过快的话就会溢出(漏桶并不会提高流出速率)。溢出的流量则直接丢弃。 令牌桶算法 会以一个恒定的速率向固定容量大小桶中放入令牌，当有流量来时则取走一个或多个令牌。当桶中没有令牌则将当前请求丢弃或阻塞。 Click to expand whatever Summary js const x = 1","categories":[{"name":"problem","slug":"problem","permalink":"https://github.com/xuegangliu/blog/categories/problem/"}],"tags":[{"name":"document","slug":"document","permalink":"https://github.com/xuegangliu/blog/tags/document/"}]},{"title":"idea常用的插件","slug":"tools/IDEA_Plugins","date":"2019-05-30T09:33:43.000Z","updated":"2019-05-30T09:33:43.000Z","comments":true,"path":"2019/05/30/tools/IDEA_Plugins/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/05/30/tools/IDEA_Plugins/","excerpt":"","text":"idea常用的插件插件列表 [FindBugs-IDEA bug查找] [JRebel for IntelliJ 热部署] [.ignore git文件忽略] [CamelCase 驼峰命名] [Lombok plugin javaBean] [Material Theme UI 主题] [Background image Plus 背景] [activate-power-mode 代码编辑屏幕颤抖] [Alibaba Java Coding Guidelines 代码规范] 链接 blog","categories":[{"name":"tools","slug":"tools","permalink":"https://github.com/xuegangliu/blog/categories/tools/"}],"tags":[{"name":"IntelliJ_IDEA","slug":"IntelliJ-IDEA","permalink":"https://github.com/xuegangliu/blog/tags/IntelliJ-IDEA/"}]},{"title":"数据库分库分表","slug":"db/database_bigdata","date":"2019-05-08T09:45:46.000Z","updated":"2019-05-08T09:45:46.000Z","comments":false,"path":"2019/05/08/db/database_bigdata/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/05/08/db/database_bigdata/","excerpt":"","text":"查看了一些blog文档,对分库分表的一些总结 为什么要分库分表查询的数据量大,访问量高,连接数达到库的阈值 数据库瓶颈 IO瓶颈 CPU瓶颈 分库分表方向水平拆分与垂直拆分 水平拆分 水平分库拆表:将一个数据库表,拆分到多个库中。 水平分表:将一个表的数据拆分到多个表中。例如:分月表、年表等 垂直拆分 垂直分库:将不同的表拆分到不同的库中。按业务类型拆分到不同的库中 垂直分表:将一个表拆分成多个表,常用的拆分为主表,并与其它拆分表进行关联。主要是单行数据列太多,大多数的列用的很少 blog链接 数据库怎么分库分表，垂直？水平？","categories":[{"name":"database","slug":"database","permalink":"https://github.com/xuegangliu/blog/categories/database/"}],"tags":[{"name":"design","slug":"design","permalink":"https://github.com/xuegangliu/blog/tags/design/"}]},{"title":"Java类加载","slug":"java/java_class_base_load","date":"2019-03-22T10:30:12.000Z","updated":"2019-03-22T10:30:12.000Z","comments":true,"path":"2019/03/22/java/java_class_base_load/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/03/22/java/java_class_base_load/","excerpt":"","text":"一、类内部加载顺序 1.父类static{} 只加载一次 2.本身static{} 只加载一次 3.父类{}块 每次 4.父类构造器 每次 5.本身{}块 每次 6.本身构造器 每次 类内部加载顺序实例 代码链接 package com.lxg.problem.clazz.v1; /** Aa @author xuegangliu 2019/3/22 14:06 **/ public interface Aa { String VERSION=”v1.0.0”; / say / void say(); / main @param args / static void main(String[] args) { System.out.println(“interface Aa main()”); } } package com.lxg.problem.clazz.v1; /** Bb @author xuegangliu 2019/3/22 14:06 ***/ public class Bb { private static String name=”Bb static prop name”; private String name1; static { System.out.println(“Bb static{}”); } { System.out.println(“Bb {}”); } public Bb(){ System.out.println(“Bb()”); } public Bb(String name1){ this.name1=name1; System.out.println(“Bb(String name1)”); } public void talk(){ System.out.println(“b.talk(){}”); } public static void main(String[] args) { System.out.println(“———-Bb main()”); Bb t=new Bb(); System.out.println(t.name1); t.talk(); } } package com.lxg.problem.clazz.v1; /** Cc @author xuegangliu 2019/3/22 14:06 **/ public class Cc extends Bb implements Aa { private static String name = “Cc”; private String name1=”c”; static { System.out.println(“Cc static{}”+VERSION); } { System.out.println(“Cc {}”); } public Cc(){ System.out.println(“Cc()”); } public Cc(String name1){ this.name1=name1; System.out.println(“Cc(String name1)”); } public static void ok(){ System.out.println(“Cc static Cc.ok()”); } @Override public void say() { System.out.println(“c.say()”); } @Override public void talk(){ super.talk(); System.out.println(“c.talk(){}”); } public static void main(String[] args) { // 1.父类的static{}只加载一次 Bb static{} // 2.当前类的static{}只加载一次 Cc static{}v1.0.0 // 3.当前方法 —–Cc main() System.out.println(“===============Cc main()”); // 4.父类 {}块 Bb {} // 5.父类 构造器 Bb() // 6.当前类 {}块 Cc {} // 7.当前类 构造器 Cc() Cc c=new Cc(); System.out.println(c.name1); c.say(); c.talk(); System.out.println(“===============”); Cc c1=new Cc(); } } 二、Java 基本数据类型 内置数据类型 (byte(8位有符号,java.lang.Byte) short(16位有符号,java.lang.Short) int(32位有符号,java.lang.Integer) long(64位有符号,java.lang.Long) float(32位,java.lang.Float) double(64位,java.lang.Double) boolean(1位) char(单一的 16 位 Unicode 字符,java.lang.Character) void(java.lang.Void) 三、Java数据结构（集合框架） 接口: java.lang.Iterable、java.util.Collection|java.util.concurrent.Callable、java.util.concurrent.Executor java.util.List java.util.Queue（单向队列）、java.util.Deque(双向队列)|java.util.concurrent.BlockingQueue,java.util.concurrent.BlockingDeque、java.util.concurrent.TransferQueue(1.7) Set、SortedSet、NavigableSet java.util.Map、java.util.SortedMap、java.util.NavigableMap|java.util.concurrent.ConcurrentMap、java.util.concurrent.ConcurrentNavigableMap 数组：java.util.Vector[同步]、java.util.ArrayList、java.util.LinkedList|java.util.concurrent.CopyOnWriteArrayList 栈：java.util.Stack 数据入栈和出栈的时间复杂度都为O(1)[Deque接口方法可以实现stack的方法，可以代替stack] 队列：java.util.PriorityQueue、java.util.ArrayDeque 不阻塞队列 ：java.util.PriorityQueue、java.util.concurrent.ConcurrentLinkedQueue 阻塞队列：java.util.concurrent.ArrayBlockingQueue、java.util.concurrent.DelayQueue、java.util.concurrent.LinkedBlockingDeque、java.util.concurrent.LinkedBlockingQueue、java.util.concurrent.PriorityBlockingQueue、java.util.concurrent.SynchronousQueue Set：java.util.HashSet、java.util.LinkedHashSet、java.util.TreeSet|java.util.concurrent.ConcurrentSkipListSet、java.util.concurrent.CopyOnWriteArraySet Map：java.util.HashMap、java.util.LinkedHashMap、java.util.IdentityHashMap、java.util.TreeMap、java.util.WeakHashMap、java.util.Hashtable[同步]、java.util.Properties[同步]|java.util.concurrent.ConcurrentHashMap、java.util.concurrent.ConcurrentSkipListMap 工具类：java.util.Arrays、java.util.Collections|java.util.concurrent.Executors","categories":[{"name":"java","slug":"java","permalink":"https://github.com/xuegangliu/blog/categories/java/"}],"tags":[{"name":"knowledge","slug":"knowledge","permalink":"https://github.com/xuegangliu/blog/tags/knowledge/"},{"name":"java_base","slug":"java-base","permalink":"https://github.com/xuegangliu/blog/tags/java-base/"},{"name":"skills","slug":"skills","permalink":"https://github.com/xuegangliu/blog/tags/skills/"}]},{"title":"设计模式原则","slug":"idea/design-principles","date":"2019-01-10T10:36:25.000Z","updated":"2019-01-10T10:36:25.000Z","comments":true,"path":"2019/01/10/idea/design-principles/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/01/10/idea/design-principles/","excerpt":"","text":"面向对象原则Java编程最基本的原则就是要追求高内聚和低耦合的解决方案和代码模块设计SOLID原则：S.O.L.I.D是面向对象设计和编程(OOD&amp;OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。 English 中文 SRP The Single Responsibility Principle 单一责任原则 OCP The Open Closed Principle 开放封闭原则 LSP The Liskov Substitution Principle 里氏替换原则 ISP The Interface Segregation Principle 接口分离原则 DIP The Dependency Inversion Principle 依赖倒置原则 介绍 单一责任原则（SRP）[单类单功能] 当需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。 类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题，非常耗时耗力。 开放封闭原则（OCP）[新扩展，旧不变]软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。 (1)通过增加代码来扩展功能，而不是修改已经存在的代码。 (2)若客户模块和服务模块遵循同一个接口来设计，则客户模块可以不关心服务模块的类型，服务模块可以方便扩展服务(代码)。 (3)OCP支持替换的服务，而不用修改客户模块。 里氏替换原则（LSP）当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系客户模块不应关心服务模块的是如何工作的；同样的接口模块之间，可以在不知道服务模块代码的情况下，进行替换。即接口或父类出现的地方，实现接口的类或子类可以代入。 接口分离原则（ISP）[解决多余]不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。 依赖注入或倒置原则（DIP） 高层模块不应该依赖于低层模块，二者都应该依赖于抽象 抽象不应该依赖于细节，细节应该依赖于抽象这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。 (1).高层模块不要依赖低层模块； (2).高层和低层模块都要依赖于抽象； (3).抽象不要依赖于具体实现； (4).具体实现要依赖于抽象； (5).抽象和接口使模块之间的依赖分离。","categories":[{"name":"idea","slug":"idea","permalink":"https://github.com/xuegangliu/blog/categories/idea/"}],"tags":[{"name":"knowledge","slug":"knowledge","permalink":"https://github.com/xuegangliu/blog/tags/knowledge/"},{"name":"design_patterns","slug":"design-patterns","permalink":"https://github.com/xuegangliu/blog/tags/design-patterns/"}]},{"title":"github_emoji","slug":"tools/github_emoji","date":"2019-01-10T10:36:25.000Z","updated":"2019-01-10T10:36:25.000Z","comments":true,"path":"2019/01/10/tools/github_emoji/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/01/10/tools/github_emoji/","excerpt":"","text":"github_emojiemoji图标使用 emoji 指南 emoji emoji 代码 commit 说明 :tada: (庆祝) :tada: 初次提交 :sparkles: (火花) :sparkles: 引入新功能 :bookmark: (书签) :bookmark: 发行/版本标签 :bug: (bug) :bug: 修复 bug :ambulance: (急救车) :ambulance: 重要补丁 :globe_with_meridians: (地球) :globe_with_meridians: 国际化与本地化 :lipstick: (口红) :lipstick: 更新 UI 和样式文件 :rotating_light: (警车灯) :rotating_light: 移除 linter 警告 :wrench: (扳手) :wrench: 修改配置文件 :heavy_plus_sign: (加号) :heavy_plus_sign: 增加一个依赖 :heavy_minus_sign: (减号) :heavy_minus_sign: 减少一个依赖 :arrow_up: (上升箭头) :arrow_up: 升级依赖 :arrow_down: (下降箭头) :arrow_down: 降级依赖 :zap: (闪电):racehorse: (赛马) :zap::racehorse: 提升性能 :chart_with_upwards_trend: (上升趋势图) :chart_with_upwards_trend: 添加分析或跟踪代码 :rocket: (火箭) :rocket: 部署功能 :white_check_mark: (白色复选框) :white_check_mark: 增加测试 :memo: (备忘录) :memo: 撰写文档 :hammer: (锤子) :hammer: 重大重构 :art: (调色板) :art: 改进代码结构/代码格式 :fire: (火焰) :fire: 移除代码或文件 :pencil2: (铅笔) :pencil2: 修复 typo :construction: (施工) :construction: 工作进行中 :construction_worker: (工人) :construction_worker: 添加 CI 构建系统 :green_heart: (绿心) :green_heart: 修复 CI 构建问题 :lock: (锁) :lock: 修复安全问题 :whale: (鲸鱼) :whale: Docker 相关工作 :apple: (苹果) :apple: 修复 macOS 下的问题 :penguin: (企鹅) :penguin: 修复 Linux 下的问题 :checkered_flag: (旗帜) :checked_flag: 修复 Windows 下的问题 简单常用emojiemoji分类简单 :ok: :up: :cool: :new: :top: :red_circle: :white_circle: :black_circle: :link: :100: :o: :x: :copyright: :tm: :on: :o2: :a: :ab: :recycle: :b: :vs: :sos: :id: :m: :mens: :free: :repeat: :hash: :cn: :smile: :rage: :shit: :v: :heart:","categories":[{"name":"tools","slug":"tools","permalink":"https://github.com/xuegangliu/blog/categories/tools/"}],"tags":[{"name":"emoji","slug":"emoji","permalink":"https://github.com/xuegangliu/blog/tags/emoji/"},{"name":"github","slug":"github","permalink":"https://github.com/xuegangliu/blog/tags/github/"}]},{"title":"travis构建配置","slug":"tools/travis_build","date":"2019-01-08T16:52:37.000Z","updated":"2019-01-08T16:52:37.000Z","comments":true,"path":"2019/01/08/tools/travis_build/","link":"","permalink":"https://github.com/xuegangliu/blog/2019/01/08/tools/travis_build/","excerpt":"","text":"travis构建github代码库中的项目 配置travis.yml 1234567891011121314151617181920212223242526272829303132333435# 选择项目的语言及版本language: pythonpython: - &quot;2.7&quot;# 打包之前的操作before_install: &quot;sudo apt-get update&quot;# 依赖安装等install: &quot;pip install -q -r requirements.txt --use-mirrors&quot;# 构建script: make html# 限制项目分支branches: only: - mybranch## 构建完成之后的命令after_success: &quot;find ./make/output -type f -exec curl --ftp-create-dirs -u $FTP_USER:$FTP_PASSWORD -T &#123;&#125; ftp://123.45.67.89/myproject/&#123;&#125; \\\\;&quot;#环境变量env: global: - &quot;FTP_USER=myusername&quot; - &quot;FTP_PASSWORD=mypassword&quot;# 邮件通知notifications: email: recipients: - 1453860636@qq.com on_success: change on_failure: always","categories":[{"name":"tools","slug":"tools","permalink":"https://github.com/xuegangliu/blog/categories/tools/"}],"tags":[{"name":"travis","slug":"travis","permalink":"https://github.com/xuegangliu/blog/tags/travis/"}]},{"title":"和融通支付","slug":"work/hrtpayment","date":"2018-11-26T09:00:00.000Z","updated":"2018-11-26T09:00:00.000Z","comments":true,"path":"2018/11/26/work/hrtpayment/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/11/26/work/hrtpayment/","excerpt":"","text":"18年末的时候,加入了和融通支付,对于我来说,这是一个新的业务方向,之前没有接触过支付业务,需要多学习 参与项目 商户支付业务管理平台 代理商 商户 支付业务了解-blog 第三方支付","categories":[{"name":"work","slug":"work","permalink":"https://github.com/xuegangliu/blog/categories/work/"}],"tags":[{"name":"pay","slug":"pay","permalink":"https://github.com/xuegangliu/blog/tags/pay/"}]},{"title":"Ubuntu基础命令","slug":"linux/shell_base","date":"2018-11-09T15:28:01.000Z","updated":"2018-11-09T15:28:01.000Z","comments":true,"path":"2018/11/09/linux/shell_base/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/11/09/linux/shell_base/","excerpt":"","text":"目录结构 软件包管理Ubuntu更新软件时的软件源配置文件是/etc/apt/sources.list。ubuntu的官方软件源分为4类： main：这个是官方维护的基本库。 restricted：官方维护的其他自由软件。 universe：自由软件，但是官方不维护。 multiverse：非自由软件，官方不维护。 aptapt是一套完整的软件包管理方案。除了最常用apt-get之外，还包括了一系列的客户端和服务器软件。例如：12sudo apt-cache search gstreamer 搜索名字中包含gstreamer的软件包。sudo add-apt-repository ppa:tualatrix/ppa添加新的软件源。 安装命令123sudo apt-get install foodpkg -i *.debwget http://* 卸载命令12sudo apt-get --purge remove foosudo apt-get remove foo","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/xuegangliu/blog/categories/linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://github.com/xuegangliu/blog/tags/shell/"}]},{"title":"Ubuntu结构","slug":"linux/ubuntu_base","date":"2018-11-09T15:28:01.000Z","updated":"2018-11-09T15:28:01.000Z","comments":true,"path":"2018/11/09/linux/ubuntu_base/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/11/09/linux/ubuntu_base/","excerpt":"","text":"目录结构 软件包管理Ubuntu更新软件时的软件源配置文件是/etc/apt/sources.list。ubuntu的官方软件源分为4类： main：这个是官方维护的基本库。 restricted：官方维护的其他自由软件。 universe：自由软件，但是官方不维护。 multiverse：非自由软件，官方不维护。 aptapt是一套完整的软件包管理方案。除了最常用apt-get之外，还包括了一系列的客户端和服务器软件。例如：12sudo apt-cache search gstreamer 搜索名字中包含gstreamer的软件包。sudo add-apt-repository ppa:tualatrix/ppa添加新的软件源。 安装命令123sudo apt-get install foodpkg -i *.debwget http://* 卸载命令12sudo apt-get --purge remove foosudo apt-get remove foo","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/xuegangliu/blog/categories/linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://github.com/xuegangliu/blog/tags/ubuntu/"}]},{"title":"JVM性能调优","slug":"java/jvm_tuning","date":"2018-11-09T15:19:01.000Z","updated":"2018-11-09T15:19:01.000Z","comments":true,"path":"2018/11/09/java/jvm_tuning/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/11/09/java/jvm_tuning/","excerpt":"","text":"JVM性能调优一、JVM内存模型及垃圾收集算法1.根据Java虚拟机规范，JVM将内存划分为： New（年轻代)[启动分配堆内存]（-Xmx:3G） 年轻代用来存放JVM刚分配的Java对象 Eden：Eden用来存放JVM刚分配的对象 Survivor1 Survivro2：两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。 Tenured（年老代）[启动分配堆内存]（-Xmx:3G） 永久代（Perm）[JVM分配内存] （-XX:PermSize -XX:MaxPermSize） 2.垃圾回收算法垃圾回收算法可以分为三类，都基于标记-清除（复制）算法： Serial算法（单线程） 并行算法 并发算法 链接JVM性能调优","categories":[{"name":"java","slug":"java","permalink":"https://github.com/xuegangliu/blog/categories/java/"}],"tags":[{"name":"knowledge","slug":"knowledge","permalink":"https://github.com/xuegangliu/blog/tags/knowledge/"},{"name":"java_jvm","slug":"java-jvm","permalink":"https://github.com/xuegangliu/blog/tags/java-jvm/"}]},{"title":"JVM命令工具","slug":"java/jvm_tools_cmd","date":"2018-02-09T15:14:30.000Z","updated":"2018-03-02T11:25:33.000Z","comments":true,"path":"2018/02/09/java/jvm_tools_cmd/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/02/09/java/jvm_tools_cmd/","excerpt":"","text":"命令工具 jps：进程列表 jinfo：进程配置信息 jstat：内存配置信息 jstack：堆栈信息 jmap：dump堆内存快照 jhat：和jmap配合使用，分析堆内存快照文件 jps-q 只输出LVMID，同进程pid -m 输出JVM启动时传给主类main()的参数。 -l 输出主类全名。如果进程执行的是jar包，则输出包名。 -v 输出JVM启动时JVM参数。 jinfo-flag name 打印给定name对应的命令行参数值。 -flag [+|-]name 更改boolean类型的命令行参数值 -flag name=value 更改name对应的命令行参数值为value。 -flags 打印传给JVM的命令参数值。 -sysprops 打印系统属性值。 链接介绍","categories":[{"name":"java","slug":"java","permalink":"https://github.com/xuegangliu/blog/categories/java/"}],"tags":[{"name":"java_jvm_cmd","slug":"java-jvm-cmd","permalink":"https://github.com/xuegangliu/blog/tags/java-jvm-cmd/"}]},{"title":"Tomcat调优","slug":"server/tomcat_tuning","date":"2018-01-09T15:16:45.000Z","updated":"2018-01-09T15:16:45.000Z","comments":true,"path":"2018/01/09/server/tomcat_tuning/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/01/09/server/tomcat_tuning/","excerpt":"","text":"1.tomcat内存配置 案例：由于服务启动后，会有大量的excel文件进行生成，以及大量的定时任务在跑。导致服务抛出堆溢出。 解决办法：设置服务JVM参数 JAVA_OPTS=’-Xms【初始化内存大小】 -Xmx【可以使用的最大内存】’最大值设置为可用内存的最大值的80% 2.tomcat线程优化1、JDK内存优化2、连接器优化`maxThreads`： Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值150。 `acceptCount`： 指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。 `minSpareThreads`： Tomcat初始化时创建的线程数。默认值25。 `maxSpareThreads`： 一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值75。 `enableLookups`： 是否反查域名，默认值为true。为了提高处理能力，应设置为false connnectionTimeout： 网络连接超时，默认值60000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。 `maxKeepAliveRequests`： 保持请求数量，默认值100。 `bufferSize`： 输入流缓冲大小，默认值2048 bytes。 `compression`： 压缩传输，取值on/off/force，默认值off。 其中和最大连接数相关的参数为maxThreads和acceptCount。如果要加大并发连接数，应同时加大这两个参数。web server允许的最大连接数还受制于*作系统的内核参数设置，通常Windows是2000个左右，Linux是1000个左右。 3.tomcat中如何禁止和允许列目录下的文件4.tomcat中如何禁止和允许主机或IP地址访问","categories":[{"name":"server","slug":"server","permalink":"https://github.com/xuegangliu/blog/categories/server/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://github.com/xuegangliu/blog/tags/tomcat/"}]},{"title":"JVM参数","slug":"java/jvm_params","date":"2018-01-09T10:13:23.000Z","updated":"2018-01-09T10:13:23.000Z","comments":true,"path":"2018/01/09/java/jvm_params/","link":"","permalink":"https://github.com/xuegangliu/blog/2018/01/09/java/jvm_params/","excerpt":"","text":"jvm参数JVM 类型以及编译器模式 类型：-server and -client 版本信息：-version and -showversion 编译器模式：-Xint（解释模式 执行所有【慢】）, -Xcomp（JIT 编译器少部分功能）, 和 - Xmixed（混合模式） 参数分类和即时（JIT）编译器诊断 标准参数 X参数 XX参数 -XX:+PrintCompilation 输出一些关于从字节码转化成本地代码的编译过程 -XX:+CITime JVM 关闭时得到各种编译的统计信息 -XX:+PrintFlagsFinal and -XX:+PrintFlagsInitial 打印所有 XX 参数及值 -XX:+PrintCommandLineFlags打印出那些已经被用户或者 JVM 设置过的详细的 XX 参数的名称和值 -XX:+HeapDumpOnOutOfMemoryError and -XX:HeapDumpPath 堆内存快照 -XX:OnOutOfMemoryError 当内存溢发生时，我们甚至可以可以执行一些指令 -XX:PermSize and -XX:MaxPermSize 永久代堆内存 -XX:InitialCodeCacheSize and -XX:ReservedCodeCacheSize代码缓存 -XX:+UseCodeCacheFlushing当代码缓存被填满时让 JVM 放弃一些编译代码内存调优所有已制定的 HotSpot 内存管理和垃圾回收算法都基于一个相同的堆内存划分：新生代（young generation）里存储着新分配的和较年轻的对象，老年代（old generation）里存储着长寿的对象。在此之外，永久代（permanent generation）存储着那些需要伴随整个 JVM 生命周期的对象，比如，已加载的对象的类定义或者 String 对象内部 Cache。接下来，我们将假设堆内存是按照新生代、老年代和永久代这一经典策略划分的。然而，其他的一些堆内存划分策略也是可行的，一个突出的例子就是新的 G1 垃圾回收器，它模糊了新生代和老年代之间的区别。此外，目前的开发进程似乎表明在未来的 HotSpot JVM 版本中，将不会区分老年代和永久代。 -Xms and -Xmx (or: -XX:InitialHeapSize and -XX:MaxHeapSize)指定 JVM 的初始和最大堆内存大小新生代垃圾回收 -XX:NewSize and -XX:MaxNewSize新生代只是整个堆的一部分，新生代设置的越大，老年代区域就会减少 -XX:NewRatio动态分配新生代与老生代比例 -XX:SurvivorRatio 动态分配新生代的伊甸园区与幸存区（伊甸园区大于幸存区【俩个幸存区大小相同】） -XX:+PrintTenuringDistribution -XX:InitialTenuringThreshold， -XX:MaxTenuringThreshold and -XX:TargetSurvivorRatio -XX:+NeverTenure and -XX:+AlwaysTenure GC 日志（垃圾收集）作用：记录了每一次的 GC 的执行时间和执行结果，通过分析 GC 日志可以优化堆设置和 GC 设置，或者改进应用程序的对象分配模式 -XX:+PrintGC（- verbose:gc） 简单日志模式 123每一次新生代（young generation）的 GC 和每一次的 Full GC 打印一行信息。[GC 246656K-&gt;243120K(376320K), 0.0929090 secs]gc类型 gc使用的前的堆空间 gc使用后的堆大小 当前堆容量 gc持续时间 XX:PrintGCDetails 详细 GC 日志模式 123456[GC[PSYoungGen: 142816K-&gt;10752K(142848K)] 246648K-&gt;243136K(375296K), 0.0935090 secs][Times: user=0.55 sys=0.10, real=0.09 secs]这是一次在 young generation 中的 GC，它将已使用的堆空间从 246648K 减少到了 243136K，用时 0.0935090 秒。此外我们还可以得到更多的信息：所使用的垃圾收集器（即 PSYoungGen）、young generation 的大小和使用情况（在这个例子中 “PSYoungGen” 垃圾收集器将 young generation 所使用的堆空间从 142816K 减少到 10752K）。CPU 时间信息 =用户空间+系统空间real gc运行真实时间 -XX:+PrintGCTimeStamps 和 - XX:+PrintGCDateStamps【绝对时间】将时间和日期也加到 GC 日志中 -Xloggc（- XX:+PrintGC - XX:+PrintGCTimeStamps）输出到指定的文件","categories":[{"name":"java","slug":"java","permalink":"https://github.com/xuegangliu/blog/categories/java/"}],"tags":[{"name":"knowledge","slug":"knowledge","permalink":"https://github.com/xuegangliu/blog/tags/knowledge/"},{"name":"java_jvm","slug":"java-jvm","permalink":"https://github.com/xuegangliu/blog/tags/java-jvm/"}]},{"title":"设计模式介绍","slug":"idea/design_patterns_base","date":"2017-07-19T13:33:02.000Z","updated":"2017-07-13T15:33:02.000Z","comments":true,"path":"2017/07/19/idea/design_patterns_base/","link":"","permalink":"https://github.com/xuegangliu/blog/2017/07/19/idea/design_patterns_base/","excerpt":"","text":"设计模式(Design pattern)设计模式简介 设计模式(Design pattern) 代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。 这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。 使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。 项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 设计模式原则 开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 设计模式的使用 开发人员的共同平台 设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 最佳的实践 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式类型创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） 设计模式直接的关系","categories":[{"name":"idea","slug":"idea","permalink":"https://github.com/xuegangliu/blog/categories/idea/"}],"tags":[{"name":"knowledge","slug":"knowledge","permalink":"https://github.com/xuegangliu/blog/tags/knowledge/"},{"name":"design_patterns","slug":"design-patterns","permalink":"https://github.com/xuegangliu/blog/tags/design-patterns/"}]},{"title":"前端问题","slug":"problem/js-problem","date":"2017-07-19T13:33:02.000Z","updated":"2017-07-13T15:33:02.000Z","comments":true,"path":"2017/07/19/problem/js-problem/","link":"","permalink":"https://github.com/xuegangliu/blog/2017/07/19/problem/js-problem/","excerpt":"","text":"问题记录 ajax怎么解决跨域？ 1，代理（通过后台操作） 2，JSONP（添加响应头，允许跨域 ）addHeader(‘Access-Control-Allow-Origin:*’);//允许所有来源访问 addHeader(‘Access-Control-Allow-Method:POST,GET’);//允许访问的方式 3，在ajax的dataType方式改为“jsonp”","categories":[{"name":"problem","slug":"problem","permalink":"https://github.com/xuegangliu/blog/categories/problem/"}],"tags":[{"name":"simple","slug":"simple","permalink":"https://github.com/xuegangliu/blog/tags/simple/"},{"name":"javascript","slug":"javascript","permalink":"https://github.com/xuegangliu/blog/tags/javascript/"}]},{"title":"亚信中国","slug":"work/asiainfo","date":"2017-06-08T09:00:00.000Z","updated":"2017-06-08T09:00:00.000Z","comments":true,"path":"2017/06/08/work/asiainfo/","link":"","permalink":"https://github.com/xuegangliu/blog/2017/06/08/work/asiainfo/","excerpt":"","text":"通信行业 参与项目 中国铁塔","categories":[{"name":"work","slug":"work","permalink":"https://github.com/xuegangliu/blog/categories/work/"}],"tags":[{"name":"communication","slug":"communication","permalink":"https://github.com/xuegangliu/blog/tags/communication/"}]},{"title":"docker基础","slug":"server/docker_base","date":"2017-01-09T14:08:37.000Z","updated":"2017-01-09T14:08:37.000Z","comments":true,"path":"2017/01/09/server/docker_base/","link":"","permalink":"https://github.com/xuegangliu/blog/2017/01/09/server/docker_base/","excerpt":"","text":"docker service docker start systemctl start docker systemctl enable docker Docker 中国官方镜像加速可通过 registry.docker-cn.comdocker --registry-mirror=https://registry.docker-cn.com daemon 为了永久性保留更改，您可以修改 /etc/docker/daemon.json 文件并添加上 registry-mirrors 键值。 123456&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125;docker --registry-mirror=https://registry.docker-cn.com daemondocker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag mysql ALTER USER ‘root‘@’%’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’;FLUSH PRIVILEGES; mongo docker pull mongo docker run –name some-mongo -p 27017:27017 -d mongo –auth //这里的–name 放在前面并映射端口 docker exec -it 容器ID /bin/bash //进入容器 mongo use admin db.createUser({user:”root”,pwd:”root”,roles:[{role:’root’,db:’admin’}]}) //创建用户,此用户创建成功,则后续操作都需要用户认证 exit ftp12docker pull docker.io/fauria/vsftpddocker run -d -v /home/vsftpd:/home/vsftpd -p 20:20 -p 21:21 -p 21100-21110:21100-21110 -e FTP_USER=test -e FTP_PASS=test --name vsftpd fauria/vsftpd 会以登录用户名 (test) 创建一个目录 (/home/vsftpd/test) 作为 ftp 根目录 测试时发现不加 -p 20:20 依然可以正常操作 sftp 使用命令sudo docker pull luzifer/sftp-share 构建docker run -d -p 2022:22 -e USER=myuser -e PASS=myverysecretpassword luzifer/sftp-share","categories":[{"name":"server","slug":"server","permalink":"https://github.com/xuegangliu/blog/categories/server/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://github.com/xuegangliu/blog/tags/docker/"}]},{"title":"Oracle常用Sql","slug":"db/oracle_base_sql","date":"2016-12-04T10:03:46.000Z","updated":"2016-12-04T10:03:46.000Z","comments":true,"path":"2016/12/04/db/oracle_base_sql/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/12/04/db/oracle_base_sql/","excerpt":"","text":"Oracle 常用SQL基本12345678910111213141516171819202122--新建表： create table table1( id varchar(300) primary key, name varchar(200) not null);--插入数据 insert into table1 (id,name) values (&apos;aa&apos;,&apos;bb&apos;);--更新数据 update table1 set id = &apos;bb&apos; where id=&apos;cc&apos;;--删除数据 delete from table1 where id =&apos;cc&apos;;--删除表 drop table table1;--修改表名： alter table table1 rename to table2--表数据复制： insert into table1 (select * from table2);--复制表结构： create table table1 select * from table2 where 1&gt;1;--复制表结构和数据： create table table1 select * from table2;--复制指定字段： create table table1 as select id, name from table2 where 1&gt;1;--条件查询： select id,name (case gender when 0 then &apos;男&apos; when 1 then ‘女’ end ) gender from table1 数学函数123456789101112131415161718192021222324252627--绝对值：abs() select abs(-2) value from dual; --(2)--取整函数（大）：ceil（） select ceil(-2.001) value from dual; --(-2)--取整函数（小）：floor（） select floor(-2.001) value from dual; --(-3)--取整函数（截取）：trunc（） select trunc(-2.001) value from dual; -- (-2)--四舍五入：round（） select round(1.234564,4) value from dual; --(1.2346)--取平方：Power（m,n） select power(4,2) value from dual; --(16)--取平方根:SQRT() select sqrt(16) value from dual; --(4)--取随机数:dbms_random(minvalue,maxvalue) select dbms_random.value() from dual; (默认是0到1之间) select dbms_random.value(2,4) value from dual; （2-4之间随机数）--取符号：Sign() select sign(-3) value from dual; --(-1) select sign(3) value from dual; --(1)--取集合的最大值:greatest(value) select greatest(-1,3,5,7,9) value from dual; --(9)--取集合的最小值:least(value) select least(-1,3,5,7,9) value from dual; --(-1)--处理Null值：nvl(空值，代替值) select nvl(null,10) value from dual; --(10) select nvl(score,10) score from student; rownum相关12345678910111213--rownum小于某个数时可以直接作为查询条件（注意oracle不支持select top）select * from student where rownum &lt;3;--查询rownum大于某个数值,需要使用子查询，并且rownum需要有别名select * from(select rownum rn ,id,name from student) where rn&gt;2;select * from (select rownum rn, student.* from student) where rn &gt;3;--区间查询select * from (select rownum rn, student.* from student) where rn &gt;3 and rn&lt;6;--排序+前n条select * from (select rownum rn, t.* from ( select d.* from DJDRUVER d order by drivernumber)t )p where p.rn&lt;10;--排序+区间查询1select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t )p where p.rn&lt;9 and p.rn&gt;6;--排序+区间查询2select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t where rownum&lt;9 )p where p.rn&gt;6;--效率远高于方式一 分页查询1234567891011--效率低select * from (select rownum rn, d.* from DJDRIVER d )p where p.rn&lt;=20 and p.rn&gt;=10;select * from (select rownum rn, d.* from DJDRIVER d )p where p.rn between 10 and 20;--效率高 select * from (select rownum rn, d.* from DJDRIVER d where rownum&lt;=20 )p where p.rn&gt;=10;--排序+区间查询1（效率低）select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t )p where p.rn&lt;=20 and p.rn&gt;=10;select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t )p where p.rn between 10 and 20;--排序+区间查询2（效率高） select * from (select rownum rn, t.* from ( select d.* from DJDRIVER d order by DJDRIVER_DRIVERTIMES)t where rownum&lt;=20 )p where p.rn&gt;=10; 时间处理日期年 yyyy yyy yy year月 month mm mon month日+星期 dd ddd(一年中第几天) dy day小时 hh hh24分 mi秒 ss12345678910111213select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;)currenttime, to_char(sysdate,&apos;yyyy&apos;) year, to_char(sysdate,&apos;mm&apos;) month, to_char(sysdate,&apos;dd&apos;) day, to_char(sysdate,&apos;day&apos;) week, to_char(sysdate,&apos;hh24&apos;)hour, to_char(sysdate,&apos;mi&apos;) minute, to_char(sysdate,&apos;ss&apos;) secondfrom dual;months_between(to_date(&apos;03-31-2014&apos;,&apos;MM-DD-YYYY&apos;),to_date(&apos;12-31-2013&apos;,&apos;MM-DD-YYYY&apos;)) next_day(sysdate,6) oracle基本sql","categories":[{"name":"database","slug":"database","permalink":"https://github.com/xuegangliu/blog/categories/database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://github.com/xuegangliu/blog/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"https://github.com/xuegangliu/blog/tags/sql/"}]},{"title":"Oracle索引","slug":"db/oracle_index_base","date":"2016-12-04T10:03:46.000Z","updated":"2016-12-04T10:03:46.000Z","comments":true,"path":"2016/12/04/db/oracle_index_base/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/12/04/db/oracle_index_base/","excerpt":"","text":"Oracle索引查询时索引类型扫描 index unique scan 索引唯一扫描，当可以优化器发现某个查询条件可以利用到主键、唯一键、具有外键约束的列，或者只是访问其中某行索引所在的数据的时候，优化器会选择这种扫描类型。 index range scan 索引范围扫描，当优化器发现在UNIQUE列上使用了大于、小于、大于等于、小于等于以及BETWEEN等就会使用范围扫描，在组合列上只使用部分进行查询，导致查询出多行数据。对非唯一的索引列上进行任何活动都会使用index range scan。 index full scan 全索引扫描，如果要查询的数据可以全部从索引中获取，则使用全索引扫描。 index fast full scan 索引快速扫描，扫描索引中的全部的数据块，与全索引扫描的方式基本上类似。两者之间的明显的区别是，索引快速扫描对查询的数据不进行排序，数据返回的时候不是排序的。“在这种存取方法中，可以使用多块读功能，也可以使用并行读入，从而得到最大的吞吐量和缩短执行时间”。 order by、group by使用索引的前提条件: 1.order by、group by中所有的列必须包含在相同的索引中并保持在索引中的排列顺序; 2.order by、group by中所有的列必须定义为非空 不走索引的情况 1.where子句中使用 is null 和 is not null 2.where子句中使用函数 3.使用like &#39;%T&#39; 进行模糊查询 4.where子句中使用不等于操作(包括：&lt;&gt;, !=, not colum &gt;= ?, not colum &lt;= ?,可以使用or代替) 5.比较不匹配数据类型，例如：select * from tablewhere name = 1name为varchar2类型字段","categories":[{"name":"database","slug":"database","permalink":"https://github.com/xuegangliu/blog/categories/database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://github.com/xuegangliu/blog/tags/oracle/"},{"name":"knowledge","slug":"knowledge","permalink":"https://github.com/xuegangliu/blog/tags/knowledge/"}]},{"title":"Vim使用","slug":"linux/vim_use","date":"2016-11-09T15:10:43.000Z","updated":"2016-11-09T15:10:43.000Z","comments":true,"path":"2016/11/09/linux/vim_use/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/09/linux/vim_use/","excerpt":"","text":"vim 基本使用 命令模式刚刚启动 vi/vim，便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式命令模式下按下i就进入了输入模式。在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 ESC键可随时退出底线命令模式。 快捷键一般模式可用的光标移动、复制粘贴、搜索替换等移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ [Ctrl] + [f] 屏幕『向下』移动一页，相当于 - - - [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 - - - [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 光标移动到非空格符的下一行 光标移动到非空格符的上一行 n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n n 为数字。光标向下移动 n 行(常用) 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 删除、复制与贴上 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 一般模式切换到编辑模式的可用的按钮说明进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) a, A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用) r, R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)在 vi 画面的左下角处会出现『--INSERT--』或『--REPLACE--』的字样 才能输入 [Esc] 退出编辑模式，回到一般模式中(常用) 一般模式切换到指令行模式的可用的按钮说明指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用)ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ vim 环境的变更 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/xuegangliu/blog/categories/linux/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://github.com/xuegangliu/blog/tags/vim/"}]},{"title":"公司高阶职位名称","slug":"others/work-name","date":"2016-11-09T15:10:43.000Z","updated":"2016-11-09T15:10:43.000Z","comments":true,"path":"2016/11/09/others/work-name/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/09/others/work-name/","excerpt":"","text":"公司高阶职位名称简介CIO、CEO、CFO、COO、CTO、CKO、CPO、CGO都是属于公司的高阶职位。 CIO（Chief Information Officer 首席信息官） 主要负责制定公司的信息政策、标准、程序的方法，并对全公司的信息资源进行管理和控制。 CEO（Chief Executive Officer 首席执行官） 主要负责企业日常经营管理决策。 CFO（Chief Financial Officer 首席财务官） 全面负责企业财务管理。 COO（Chief Operating Officer 首席运营官） 具体负责公司的日常运营。 CTO（Chief Technology Officer 首席技术官） 企业内负责技术的最高负责人，由于互联网的迅猛发展，有时CT0和CIO是同一个人。 CKO（Chief Knowledge Officer 首席知识官） 主要负责企业内部的知识管理等相关工作 CPO（Chief Procurement Officer 首席采购官） 负责企业采购方面的全面工作。 CGO（Chief Game Officer 首席游戏官） 这个主要是游戏公司或网吧里设置的岗位或系统，一般企业里没有这样的岗。当然，也不排除一些前卫的公司针对90后特意设置这样的岗位。","categories":[{"name":"others","slug":"others","permalink":"https://github.com/xuegangliu/blog/categories/others/"}],"tags":[{"name":"work","slug":"work","permalink":"https://github.com/xuegangliu/blog/tags/work/"}]},{"title":"idea快捷键","slug":"tools/IDEA_use","date":"2016-11-09T15:10:43.000Z","updated":"2016-11-09T15:10:43.000Z","comments":true,"path":"2016/11/09/tools/IDEA_use/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/09/tools/IDEA_use/","excerpt":"","text":"开发工具IntelliJ Idea实用快捷键: Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ） Ctrl+D 复制行 Ctrl+X 删除行 快速修复 alt+enter (modify/cast) 代码提示 alt+/ ctr+G 定位某一行 Shift+F6 重构-重命名 Ctrl+R 替换文本 Ctrl+F 查找文本 Ctrl+E 最近打开的文件 Ctrl+J 自动代码 组织导入 ctr+alt+O 格式化代码 ctr+alt+L 大小写转化 ctr+shift+U IntelliJ Idea 常用快捷键列表 Alt+回车 导入包,自动修正 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 Ctrl+Alt+L 格式化代码 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) Ctrl+E或者Alt+Shift+C 最近更改的代码 Ctrl+R 替换文本 Ctrl+F 查找文本 Ctrl+Shift+Space 自动补全代码 Ctrl+空格 代码提示 Ctrl+Alt+Space 类名或接口名提示 Ctrl+P 方法参数提示 Ctrl+Shift+Alt+N 查找类中的方法或变量 Alt+Shift+C 对比最近修改的代码 Shift+F6 重构-重命名 Ctrl+Shift+先上键 Ctrl+X 删除行 Ctrl+D 复制行 Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ） Ctrl+J 自动代码 Ctrl+E 最近打开的文件 Ctrl+H 显示类结构图 Ctrl+Q 显示注释文档 Alt+F1 查找代码所在位置 Alt+1 快速打开或隐藏工程面板 Ctrl+Alt+ left/right 返回至上次浏览的位置 Alt+ left/right 切换代码视图 Alt+ Up/Down 在方法间快速移动定位 Ctrl+Shift+Up/Down 代码向上/下移动。 F2 或Shift+F2 高亮错误或警告快速定位 代码标签输入完成后，按Tab，生成代码。 选中文本，按Ctrl+Shift+F7 ，高亮显示所有该文本，按Esc高亮消失。 Ctrl+W 选中代码，连续按会有其他效果 选中文本，按Alt+F3 ，逐个往下查找相同文本，并高亮显示。 Ctrl+Up/Down 光标跳转到第一行或最后一行下 Ctrl+B 快速打开光标处的类或方法 1. IDEA内存优化因机器本身的配置而配置：12345678\\IntelliJ IDEA 8\\bin\\idea.exe.vmoptions ----------------------------------------- -Xms64m -Xmx256m -XX:MaxPermSize=92m -ea -server -Dsun.awt.keepWorkingSetOnMinimize=true 2. 查询快捷键 CTRL+N 查找类 CTRL+SHIFT+N 查找文件 CTRL+SHIFT+ALT+N 查找类中的方法或变量 CIRL+B 找变量的来源 CTRL+ALT+B 找所有的子类 CTRL+SHIFT+B 找变量的类 CTRL+G 定位行 CTRL+F 在当前窗口查找文本 CTRL+SHIFT+F 在指定窗口查找文本 CTRL+R 在 当前窗口替换文本 CTRL+SHIFT+R 在指定窗口替换文本 ALT+SHIFT+C 查找修改的文件 CTRL+E 最近打开的文件 F3 向下查找关键字出现位置 SHIFT+F3 向上一个关键字出现位置 F4 查找变量来源 CTRL+ALT+F7 选中的字符查找工程出现的地方 CTRL+SHIFT+O 弹出显示查找内容 3. 自动代码 ALT+回车 导入包,自动修正 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 ALT+INSERT 生成代码(如GET,SET方法,构造函数等) CTRL+E 最近更改的代码 CTRL+SHIFT+SPACE 自动补全代码 CTRL+空格 代码提示 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+J 自动代码 CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 4. 复制快捷方式 CTRL+D 复制行 CTRL+X 剪切,删除行 5. 其他快捷方式 CIRL+U 大小写切换 CTRL+Z 倒退 CTRL+SHIFT+Z 向前 CTRL+ALT+F12 资源管理器打开文件夹 ALT+F1 查找文件所在目录位置 SHIFT+ALT+INSERT 竖编辑模式 CTRL+/ 注释// CTRL+SHIFT+/ 注释/…/ CTRL+W 选中代码，连续按会有其他效果 CTRL+B 快速打开光标处的类或方法 ALT+ ←/→ 切换代码视图 CTRL+ALT ←/→ 返回上次编辑的位置 ALT+ ↑/↓ 在方法间快速移动定位 SHIFT+F6 重构-重命名 CTRL+H 显示类结构图 CTRL+Q 显示注释文档 ALT+1 快速打开或隐藏工程面板 CTRL+SHIFT+UP/DOWN 代码向上/下移动。 CTRL+UP/DOWN 光标跳转到第一行或最后一行下 ESC 光标返回编辑框 SHIFT+ESC 光标返回编辑框,关闭无用的窗口 F1 帮助千万别按,很卡! CTRL+F4 非常重要下班都用 Eclipse Ctrl + 2,L 补全 自己改为Alt + q 选中按F4 或 Ctrl + t 进入层次视图—–体系结构 Alt+/ 内容补全 Ctrl + 1 帮助 Ctrl + d 删除当前行 Ctrl + M 最大化当前的Edit或View (再按则反之) Ctrl + f 查找/替换 Ctrl + 点击 进入源码 Alt + Shift + r 改名 Ctrl + Shift + o 快速导包 Ctrl + Shift + r 打开源 Ctr + Shift + f 格式化代码 Ctrl + Shift + x 变大写 Ctrl + Shift + x 变小写 Ctrl + Shift + t 类查询 syso + Alt + / 输出 Alt + ← 前一个编辑的页面 Alt + → 下一个编辑的页面 Alt + 上箭头 上移 Alt + 下箭头 下移 Ctrl + / 单行注释 Ctrl + Shift + / 多行注释 Ctrl + Shift + \\ 取消注释 Ctrl + Shift + c 适用于各种文档的注释 Ctrl + Alt + 上箭头/下箭头 上复制/下复制 Alt + Shift + s 源操作 Alt + Shift + t 方法操作 Alt + Shift + z 语句操作 Alt + Shift + m 提取方法 Alt + Shift + L 提取本地变量 Alt + 1 packageExporer显示 Alt + 2 console显示 Alt + 3 Outline显示 小绿圆圈——&gt;方法 小绿三角——&gt;属性 带土红色 s —–&gt;静态 Alt + 4 navigator导航显示","categories":[{"name":"tools","slug":"tools","permalink":"https://github.com/xuegangliu/blog/categories/tools/"}],"tags":[{"name":"IntelliJ_IDEA","slug":"IntelliJ-IDEA","permalink":"https://github.com/xuegangliu/blog/tags/IntelliJ-IDEA/"}]},{"title":"git基础使用","slug":"tools/git_use_base","date":"2016-11-09T15:10:43.000Z","updated":"2016-11-09T15:10:43.000Z","comments":true,"path":"2016/11/09/tools/git_use_base/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/09/tools/git_use_base/","excerpt":"","text":"git 常用命令(含删除文件)Git常用操作命令收集：1) 远程仓库相关命令 检出仓库：$ git clone git://github.com/jquery/jquery.git 查看远程仓库：$ git remote -v 添加远程仓库：$ git remote add [name] [url] 删除远程仓库：$ git remote rm [name] 修改远程仓库：$ git remote set-url –push[name][newUrl] 拉取远程仓库：$ git pull [remoteName] [localBranchName] 推送远程仓库：$ git push [remoteName] [localBranchName] 2）分支(branch)操作相关命令 查看本地分支：$ git branch 查看远程分支：$ git branch -r 创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支 切换分支：$ git checkout [name] 创建新分支并立即切换到新分支：$ git checkout -b [name] 删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项 合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并 创建远程分支(本地分支push到远程)：$ git push origin [name] 删除远程分支：$ git push origin :heads/[name] 我从master分支创建了一个issue5560分支，做了一些修改后，使用git push origin master提交，但是显示的结果却是’Everything up-to-date’，发生问题的原因是git push origin master 在没有track远程分支的本地分支中默认提交的master分支，因为master分支默认指向了origin master 分支，这里要使用git push origin issue5560：master 就可以把issue5560推送到远程的master分支了。 如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，那么可以这么做。 $ git push origin test:master // 提交本地test分支作为远程的master分支 //好像只写这一句，远程的github就会自动创建一个test分支 $ git push origin test:test // 提交本地test分支作为远程的test分支 如果想删除远程的分支呢？类似于上面，如果:左边的分支为空，那么将删除:右边的远程的分支。 $ git push origin :test // 刚提交到远程的test将被删除，但是本地还会保存的，不用担心 3）版本(tag)操作相关命令 查看版本：$ git tag 创建版本：$ git tag [name] 删除版本：$ git tag -d [name] 查看远程版本：$ git tag -r 创建远程版本(本地版本push到远程)：$ git push origin [name] 删除远程版本：$ git push origin :refs/tags/[name] 4) 子模块(submodule)相关操作命令 添加子模块：$ git submodule add [url] [path]如：$ git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs 初始化子模块：$ git submodule init —-只在首次检出仓库时运行一次就行 更新子模块：$ git submodule update —-每次更新或切换分支后都需要运行一下 删除子模块：（分4步走哦） 1)$ git rm –cached [path] 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉 3) 编辑“.git/config”文件，将子模块的相关配置节点删除掉 4) 手动删除子模块残留的目录 5）忽略一些文件、文件夹不提交在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如target,bin,*.db 5) 修改文件后,切换分支 git stash save &quot;comment info&quot; 保存到栈中,当前目录和版本库目录一直,将修改的信息保存起来 git stash list 查看保存的信息 git stash pop 取出最后一次保存的信息 git stash applay 相应的栈内stash@{number} 取出相应的保存信息 git stash drop 相应的栈内stash@{number} 删除之前保存的信息 6) 创建新分支,无提交历史git checkout --orphan name","categories":[{"name":"tools","slug":"tools","permalink":"https://github.com/xuegangliu/blog/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"https://github.com/xuegangliu/blog/tags/git/"}]},{"title":"Maven构建","slug":"tools/maven_build","date":"2016-11-09T15:10:43.000Z","updated":"2016-11-09T15:10:43.000Z","comments":true,"path":"2016/11/09/tools/maven_build/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/09/tools/maven_build/","excerpt":"","text":"Maven构建maven生命周期官方文档 基本的生命周期 验证（validate） - 验证项目是否正确，所有必要的信息可用 编译（compile） - 编译项目的源代码 测试（test） - 使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署 打包（package） - 采用编译的代码，并以其可分配格式（如JAR）进行打包。 验证（verify） - 对集成测试的结果执行任何检查，以确保满足质量标准 安装（install） - 将软件包安装到本地存储库中，用作本地其他项目的依赖项 部署（deploy） - 在构建环境中完成，将最终的包复制到远程存储库以与其他开发人员和项目共享。","categories":[{"name":"tools","slug":"tools","permalink":"https://github.com/xuegangliu/blog/categories/tools/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://github.com/xuegangliu/blog/tags/maven/"}]},{"title":"Linux工具","slug":"linux/linux_tools","date":"2016-11-09T15:07:29.000Z","updated":"2016-11-09T15:07:29.000Z","comments":true,"path":"2016/11/09/linux/linux_tools/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/09/linux/linux_tools/","excerpt":"","text":"程序构建1.配置 -&gt; 2.编译 -&gt; 3.安装 配置做的工作主要是检查当前环境是否满足要安装软件的依赖关系，以及设置程序安装所需要的初始化信息，比如安装路径，需要安装哪些组件；配置完成，会生成makefile文件供第二步make使用； 编译是对源文件进行编译链接生成可执行程序； 安装做的工作就简单多了，就是将生成的可执行文件拷贝到配置时设置的初始路径下； 1234./configure --help./configure --prefix=/usr/local/snmpmake -f myMakefilemake install 程序调试gdb 程序交互调试 性能优化系统123topfreevmstat 进入交互模式后:输入M，进程列表按内存使用大小降序排序，便于我们观察最大内存使用者使用有问题（检测内存泄漏问题）;输入P，进程列表按CPU使用大小降序排序，便于我们观察最耗CPU资源的使用者是否有问题；top第三行显示当前系统的，其中有两个值很关键:%id：空闲CPU时间百分比，如果这个值过低，表明系统CPU存在瓶颈；%wa：等待I/O的CPU时间百分比，如果这个值过高，表明IO存在瓶颈； 程序如果IO存在性能瓶颈，top工具中的%wa会偏高；进一步分析使用iostat工具如果%iowait的值过高，表示硬盘存在I/O瓶颈。如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有大量io在等待。 分析进程调用 pstack用来跟踪进程栈 pstack [pid] strace用来跟踪进程中的系统调用","categories":[{"name":"linux","slug":"linux","permalink":"https://github.com/xuegangliu/blog/categories/linux/"}],"tags":[{"name":"knowledge","slug":"knowledge","permalink":"https://github.com/xuegangliu/blog/tags/knowledge/"},{"name":"bug_test","slug":"bug-test","permalink":"https://github.com/xuegangliu/blog/tags/bug-test/"}]},{"title":"Python基础","slug":"python/python_base","date":"2016-11-08T14:49:38.000Z","updated":"2016-11-08T14:49:38.000Z","comments":true,"path":"2016/11/08/python/python_base/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/11/08/python/python_base/","excerpt":"","text":"python3 规定 缩进规定、多行语句(+) 指定源码编码# -*- coding: utf-8 -*- #coding=utf8 注释123456789# 方法1&apos;&apos;&apos;注释方法2&apos;&apos;&apos;&quot;&quot;&quot;注释方法3&quot;&quot;&quot; 标准数据类型 Number 数字(int、bool、float、complex) ,不可变 String 字符串, 不可变, 序列 ‘’’aa’’’ “””bbb””” \\转义字符 r不转义 索引从0开始，从-1倒序 List 列表, [] ,序列, 有序 Tuple 元组 ,不可变 ,(), 序列 Set 集合 {xx} 或者 set() Dictionary 字典, 无序, {key:value} 类型判断注意 tpye() 不会认为子类是一种父类类型 isinstance()会认为子类是一种父类类型 is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。 模块 模块导入 import 与 from xx import a,b,c 面向对象 类属性与方法 __private_attrs：两个下划线开头，声明该属性为私有 类的方法 第一个参数必须为self __private_method：两个下划线开头，私有方法 类的专有方法： init : 构造函数，在生成对象时调用 del : 析构函数，释放对象时使用 repr : 打印，转换 setitem : 按照索引赋值 getitem: 按照索引获取值 len: 获得长度 cmp: 比较运算 call: 函数调用 add: 加运算 sub: 减运算 mul: 乘运算 div: 除运算 mod: 求余运算 pow: 乘方 错误异常12345try: breakexcept ValueError: //","categories":[{"name":"python","slug":"python","permalink":"https://github.com/xuegangliu/blog/categories/python/"}],"tags":[{"name":"python_base","slug":"python-base","permalink":"https://github.com/xuegangliu/blog/tags/python-base/"}]},{"title":"中交兴路","slug":"work/sinoiov","date":"2016-08-08T09:00:00.000Z","updated":"2016-08-08T09:00:00.000Z","comments":true,"path":"2016/08/08/work/sinoiov/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/08/08/work/sinoiov/","excerpt":"","text":"千方科技子公司 参与项目 保犇保险 油品-中石油加油卡 柴油联名卡","categories":[{"name":"work","slug":"work","permalink":"https://github.com/xuegangliu/blog/categories/work/"}],"tags":[{"name":"highway","slug":"highway","permalink":"https://github.com/xuegangliu/blog/tags/highway/"}]},{"title":"Java反射基础","slug":"java/java_class_base","date":"2016-07-28T10:30:12.000Z","updated":"2016-07-28T10:30:12.000Z","comments":true,"path":"2016/07/28/java/java_class_base/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/07/28/java/java_class_base/","excerpt":"","text":"Java 反射在运行中，可以使程序创建和控制任何类的对象。 缺点 性能: 对类的逻辑结构信息获取后，然后对这些类进行操作（所以相对于源码方式速度较低） 模糊程序内部处理逻辑等 Java reflection使类和数据结构按名称动态检索相关的信息并可以操作这些信息。 java.lang.reflect.*(Field,Method,Constructor)java.lang.Class 反射的实现方式 通过对象的getClass()，例如：String.getClass 通过对象实例方法获取，例如：String.classs 通过Class.forName(“java.lang.String”),加载时，会将对应的静态方法加载","categories":[{"name":"java","slug":"java","permalink":"https://github.com/xuegangliu/blog/categories/java/"}],"tags":[{"name":"knowledge","slug":"knowledge","permalink":"https://github.com/xuegangliu/blog/tags/knowledge/"},{"name":"java_base","slug":"java-base","permalink":"https://github.com/xuegangliu/blog/tags/java-base/"}]},{"title":"Online-gitbook-links","slug":"links/online_gitbook","date":"2016-07-28T10:30:12.000Z","updated":"2016-07-28T10:30:12.000Z","comments":true,"path":"2016/07/28/links/online_gitbook/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/07/28/links/online_gitbook/","excerpt":"","text":"Gitbook链接Java NIO简明教程","categories":[{"name":"links","slug":"links","permalink":"https://github.com/xuegangliu/blog/categories/links/"}],"tags":[{"name":"gitbook","slug":"gitbook","permalink":"https://github.com/xuegangliu/blog/tags/gitbook/"},{"name":"book","slug":"book","permalink":"https://github.com/xuegangliu/blog/tags/book/"}]},{"title":"tomcat服务","slug":"server/tomcat_base","date":"2016-07-28T10:30:12.000Z","updated":"2016-07-28T10:30:12.000Z","comments":true,"path":"2016/07/28/server/tomcat_base/","link":"","permalink":"https://github.com/xuegangliu/blog/2016/07/28/server/tomcat_base/","excerpt":"","text":"Tomcat服务组织架构12345server├── service ├── container 处理线程请求(connector接收的请求) [Engine Host Context Wrapper] ├── connector 负责接收浏览器发过来的TCP连接请求 ├── connector 设计模式 责任链设计模式 模板模式 工厂模式 单例模式 门面设计模式 观察者设计模式 命令设计模式","categories":[{"name":"server","slug":"server","permalink":"https://github.com/xuegangliu/blog/categories/server/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://github.com/xuegangliu/blog/tags/tomcat/"}]},{"title":"学校练习","slug":"links/school_demo","date":"2014-11-28T10:30:12.000Z","updated":"2014-11-28T10:30:12.000Z","comments":true,"path":"2014/11/28/links/school_demo/","link":"","permalink":"https://github.com/xuegangliu/blog/2014/11/28/links/school_demo/","excerpt":"","text":"ProjectC语言 内师大绩点计算器 HTML 凯晨数字 美人鱼 练习 练习2 Java 宿舍管理系统 ACM在线评测系统 个人博客 java-web-basic-framework PHP 留言板系统 其它 node AngularJS AngularJS2 Csharp cpp bootstrapTest extJs js-tools vue insurance jQueryMobile test-makefile go my-app reactTest bat docker-build sh 微信小程序 miniprogram","categories":[{"name":"links","slug":"links","permalink":"https://github.com/xuegangliu/blog/categories/links/"}],"tags":[{"name":"school","slug":"school","permalink":"https://github.com/xuegangliu/blog/tags/school/"},{"name":"project","slug":"project","permalink":"https://github.com/xuegangliu/blog/tags/project/"},{"name":"self","slug":"self","permalink":"https://github.com/xuegangliu/blog/tags/self/"}]}]}